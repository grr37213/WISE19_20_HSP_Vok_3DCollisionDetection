Das L0-Level (siehe \ref{l0}) beschäftigt sich mit der Datenrepräsentation von Modellen, Zeit und Raum.\\

Die Repr"asentation stellt sich dabei jedoch Anforderungen verschiedener technologischer Perspektiven:
		\begin{itemize}
			\item graphische Darstellung/Rendering
				F"ur die graphische Darstellung m"ussen bestimmte Formate eingehalten werden. Datenkonfomit"at mit graphischen Bibliotheken erspart umst"andliche Umwandlungen von Repr"asentationen.
			\item physikalische Berechnung
				F"ur die Kollisionsberechnung k"onnen bestimmte Repr"asentationen vorteilhaft sein. Die Repr"asentation versucht m"oglichst statisch Information "uber Objekte bereitzustellen und vermeidet dynamische Nachberechnung von Objekteigenschaften.
			\item menschliche Manipulation
				F"ur Entwicklungszwecke ist es zum Vorteil, wenn Objektrepr"asentationen menschlich lesbar, verst"andlich und nachvollziehbar sind. Dieses Konzept vereinfacht die Erstellung von Tests und die Behebung von Fehlern. Unter diesen Aspekt fällt ebenso die Konformität mit Tooling.
		\end{itemize}

Im Folgenden werden die zu repräsentierenden, angesprochenen Konzepte näher erläutert.

\subsection{Zeit}
Es existieren die Realzeit der echten Welt und die Simulationszeit. Die Zeiten können prinzipiell asynchron ablaufen.\\
In einer Echzeitsimulation müssen beide zeiten jedoch synchronisiert werden.\\
Es genügt dabei, diese Synchronisation in kurzen Zeitabschnitten herzustellen.\\
Diese zeitlichen Abstände werden oft Ticks genannt (siehe \ref{sec:tick}).\\
Gefordert sind hierbei Tickraten von ca. $60 Ticks/s \Rightarrow 16.6ms /Tick$.\\
Realzeit wird in Microsekunden-Genauigkeit vom ausführenden Betriebssystem zu Beginn jedes Ticks erhalten. Das Intervall der vergangenen Simulationszeit kann so durch den Abgleich mit der erhaltenen Zeit des vorherigen Ticks errechnet werden. Dieser Anzahl Microsekunden wird dann in einen Floating-Point-Wert in Sekunden umgewandelt, welche als Zeitfaktor in physikalischen Berechnungen verwendet werden kann.

\subsection{Raum}
Der geforderte Raum ist 3-dimensional. Die Darstellung der Positionen im Raum erfolgt über 3-dimensionale Vektoren in der Einheit von Metern.\\
Es wird daher ein Datentyp für Dezimalbrüche verwendet um kleinere Raumanteile zu erfassen.
Floating-Point-Dezimalbrüche würden sich anbieten, jedoch tritt für große Räume ein Genauigkeitsproblem auf Grund der Werteverteilung in Floating-Point Datentypen auf.\\
Sei $\mathbb{F} \subset \mathbb{R}$ mit $\mathbb{F}$ als Floating-Point-Datentyp, so ist die Verteilung der verfügbaren Werte des Floats dichter je näher am Ursprung($0.0$) \cite{floatdistribution}.\\
Für eine Darstellung im Raum $\mathbb{F}^3$ existiert dabei das selbe Problem in 3 Dimensionen. Physikalische Prozesse können daher inkonsistent in Abhängigkeit zum Ort im Raum sein.
Es wird allerdings an dieser stelle Konsistenz der simulierten Prozesse unabhängig vom Ort im Raum gefordert.\\
Lösungen des Problems sind
\begin{enumerate}
	\item Relativierung interagierender Objekte zueinander.\\
		Funktioniert unter der Annahme, dass Entfernungen zwischen interagierenden Objekten gegenüber der Gesamtgröße des Raums relativ klein sind.
	\item Aufteilung des Raums und Positionswerte von Objekten relativiert zu einem nahen Raumanteilsursprung\\
		Sorgt dafür das Objektpositionswerte nicht dem Ungenauigkeitsproblem verfallen, wenn Objekte sich weit vom Raumursprung befinden. Dafür muss ein Positionsdatentyp $\mathbb{S}$ definiert werden, welcher den betreffenden Raumanteil pro Positionswert mitführt $\mathbb{S}:\mathbb{Z}\times\mathbb{F}$. Die Relativierung zweier Positionen kann dann über eine Funktion $ \mathbb{S}\times \mathbb{S} \mapsto \mathbb{F}$ realisiert werden, wodurch die Distanz wieder auf eine gängige Einheit euklidischen Maßes zurückgeführt werden kann (hier in Metern).
\end{enumerate}

Positionen und Richtungen im Raum werden demnach mit Vektoren $s\in\mathbb{S}^3$ dargestellt. Für Berechnungsvorgänge werden Positionen zunächst relativiert, dann in $\mathbb{F}^3$ in der Einheit Meter umgewandelt.

\subsection{Objektform}
\label{sec:l0_objects}
Objekte besitzen eine geometrische Form, welche relativ zur Objektposition angegeben wird. 
Wie in der Computergrafik üblich werden Objekte in Form von Vertices (Ecken) angegeben, welche zu Dreiecken verbunden werden.\\
Für das Intrusionsproblem im speziellen genügt einschätzungsweise die Betrachtung der Hülle des Objektes. Es ist üblicherweise auch nur die Hülle des Objektes, die für die Grafik von Interesse ist. Die Hülle stellt also die minimal benötigte Objektrepräsentation dar.\\

Über die Grafikbibliothek OpenGL können Objekte graphisch dargestellt werden. Die Bibliothek fordert die Darstellung folgendermaßen:\\
Es wird eine Ansammlung an Ecken (eng. vertices) über 3D-Vektoren (32Bit-floating-point) gegeben. Weiter eine Ansammlung von 3er Gruppen an Integers zu der Eckenansammlung um Dreiecke zu spezifizieren. Die Dreiecke Bilden dann den Körper. Diese Art der Darstellung entspricht der einer Polygon-Mesh.\\
Da diese Art der Repräsentation von OpenGL auf diese Weise im allgemeinen verwendet wird und von der Seite der Physiksimulation keine konkreten Anforderungen gestellt sind, wurde entschieden die Objektrepresentationen gleich zu halten, um dynamische Unformungen zwischen Repräsentationen zu vermeiden.\\
Die Vertices sind relativ zu einer dem Objekt zugehörigen Positionsvariable angegeben. Interagierende Objekte müssen sich daher vor einer Interaktion gegenseitig relativieren.\\

Im Verlauf dieses Projekts werden Objekte außerdem als starr/rigide, unveränderlich und unzerstörbar angenommen.
	
\subsection{Bewegung}
Eititäten in der 3D-Simulation nehmen eine Position im Raum ein.\\
Physikalische 3D-Objekte sind Entitäten und haben zusätzlich eine Ausrichtung im Raum (Rotation).\\
Beide dieser Größen (Position und Rotation) können einer zeitlichen Änderung unterliegen (Geschwindigkeit, Drehgeschwindigkeit).\\
An dieser Stelle wird festgelegt: Während eines Ticks ändern sich diese konstanten zeitlichen Änderungsgrößen standardmäßig nicht. Vertexpositionen können durch Transformation mit Transformationsmatrizen leicht zu bliebig ausgewählten Zeitpunkten des Ticks ermittelt werden.\\
Denkbar sind daher auch weitere Transformationsmöglichkeiten (z.B.~Skalierung).\\
Eine weitere Form der Bewegung, auf die hier nicht im Implementiertungsumfang des Projekts enthalten sein soll, ist die der Animation, welche eine übliche Art der Bewegung in vielen Spielen darstellt und daher erwähnt werden sollte.\\
Animation funktioniert meist über die Zuweisung von Objektecken zu einer Drehachse (Gelenk) an einem Skelett, welche in einer Baumstruktur nacheinander transformiert werden. Animierte Objekte sind entweder nicht kontinuierlich (bestehen aus mehreren Teilen), oder aber flexibel (nicht rigide), durch die Problemstellung der Animation an Gelenken (Ecken des Objekts, welche zu mehreren Teilen des animierten Objekts gehören müssen). Gelenke werden daher gegenüber der Kollisionslogik oft als Kugeln approximiert (vgl. \ref{fig:chitbox}).


